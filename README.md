# **JControl**
`JControl是一款基于spring boot starter的权限控制框架。`

### **JControl的设计与实现**
JControl模块主要对系统前后端分离后的交互进行安全控制，包括角色权限控制，会话的安全保障、前端菜单数据的获取、后端接口的访问控制、登录拦截控制等。
### **spring boot starter 的开发**
在全面拥抱spring boot的时代，方便好用的spring boot starter绝对是一个助推者。所以本文的JControl使用基于spring boot starter的开发模式。
首先，需要引入spring boot的starter依赖和自动装配依赖，这样可以使得一些必要的配置项用户可以在配置文件中配置。配置项以“jleo.jcontrol”加上配置名例如：“interceptUrl”、“loginUrl”等，分别代表需要登录拦截的地址、登录验证地址。建议登录拦截地址使用“/**”开启全局拦截，当然每一个配置项都有默认的值。加密密钥的配置项有默认值为“JohnnyLeo”，也可以自己设置，如果加密密钥被泄露可能会导致会话内容解密从而被泄露。实现方式可以改进为项目启动时初始化一个随机序列，这样更加安全。
加入spring boot starter的启动文件，将启动类配置进去。spring boot starter的加载方式类似java spi的加载方式，通过扫描路劲下的特定文件加载文件中配置的类路径。启动类中再通过包扫描注解，将需要的包扫描进程序后，便可以引用到JControl模块的类。
### **后端接口权限控制**
后端使用AOP编程实现方法的权限控制。用户信息、角色信息、用户角色对应信息都保存在数据库中，集成JControl后，在需要进行控制的方法上加上注解“@Permission”可以对该方法实现前置增强。该注解有三个属性，一个是“user”表示范围内的用户，“role”表示范围内的角色，“access”表示范围内的用户是否有权限，默认为true表示有权通过。动态代理基于spring aop，它集成了AspectJ的编程语法，但实现原理依然是使用自身底层的JDK动态代理和CGLib动态代理。加入“@Permission”注解的方法作为织入点，前置增强代码为判断当前用户是否为可通行用户，所以加入该注解的方法默认会要求用户登录。
当只设置了注解的“user”属性或者“role”属性时很方便判断用户是否在范围内。当两个属性都设置的时候，若access为true，则满足任何一个条件的用户都有权限通过，若access为false时，任何满足条件的用户都无法通过。
JControl有统一返回json格式。code属性是返回码，-1表示服务器端发生错误、访问错误等，包括抛出异常而未正确返回、没有权限，0表示正常返回，1表示未登录。message属性为返回信息，当正确返回时它表示返回的数据，当未正确返回时它表示发生错误的内容。所有由JControl返回的错误都会在message属性中加上“[JControl]”字符串。
### **菜单信息的返回**
为了支持前后端分离，JControl属于后端框架，所以没有权限去直接控制前端的显示效果。为了实现不同的角色有不同的菜单选项，JControl主动暴露一个接口：“/jcontrol/getMenu”，此接口有固定的json返回格式，这个json对象是一个数组格式，每个元素表示一个一级菜单，属性包括：菜单ID，菜单名，菜单地址，子菜单数组。菜单ID为字母，由于菜单之间的关系由菜单ID表示，长度为1的ID表示一级菜单，长度为2的ID表示二级菜单，数据库的限制为最长10个字符，所以最多是10级菜单。每一级菜单之间的顺序为字符串的排序，例如a > b > c，每个菜单的子菜单的前缀必须为当前菜单ID，例如ID为a的菜单的子菜单必须是aa、ab、ac，由于每一级菜单的长度、前缀都确定了，并且只有26个字母，所以同一级菜单最多只能有26个，例如一级菜单只能有26个，a菜单的子菜单只能有aa、ab、ac……共26个，b菜单的子菜单只能有ba、bb、bc……共26个。由于这些硬性条件，才能让关系复杂的众多菜单可以通过简便的拼接逻辑将他们整合到一起展示给前端。
前端的解析可以通过解析返回的json对象内部的菜单关系来动态拼接菜单按钮，也可以将所有的菜单通过代码写出来，通过判断返回的对象中是否包含有该菜单的ID来控制是否显示该菜单。
### **登录拦截和会话保持**
由于用户配置了需要登录拦截的地址，实现原理便是读取用户配置，使用spring的拦截器，一个拦截器是全路径拦截器，用于默认支持跨域请求，一个是登录拦截器，将用户配置中的拦截地址和非拦截地址设置入拦截器。
由于JControl不控制业务，所以登录功能的判断需要开发人员自己编写，但是为了JControl做会话保持，所以当用户登录成功的代码逻辑之后，需要调用JControl的API，传入登录的用户，让JControl向客户端的cookie中写入加密的登录信息。
同时，开发人员不用手动向cookie里面加入信息，只需要调用JControl的conversation的API，便可以向cookie里面加入加密的信息。读取cookie的信息操作也是一样简单。内容在cookie里面保存类型为字符串，所以需要开发者将对象等信息转换为格式化的json字符串。